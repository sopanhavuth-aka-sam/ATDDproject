<!doctype html>
<html lang="en">
<head>



	<meta charset="utf-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src='https://api.mapbox.com/mapbox.js/v2.2.3/mapbox.js'></script>
    <link href='https://api.mapbox.com/mapbox.js/v2.2.3/mapbox.css' rel='stylesheet' />
	
	<script src="jquery-2.2.3.min.js"></script>
	<link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.2/css/select2.min.css" rel="stylesheet" />
	<script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.2/js/select2.min.js"></script>
	<script src="Zebra_Datepicker-master/public/javascript/zebra_datepicker.js"></script>
	<link href="Zebra_Datepicker-master/public/css/default.css" rel="stylesheet">

<style>
	body
	{
		margin: 0;
		padding: 0;
	}

	#map 
	{ 
		position:absolute; 
		top:0;
		bottom:0; 
		width:75%; 
	}
	
	#slider{
		position: absolute;
	}
	
	#input_section
	{
		position: absolute;
		right: 0;
		background-color:#eeeeee;
		width:25%;
		height:60%;
		
	}
</style>

<script>

	//parsing "Species data" into an array of objects (row == object)
	d3.csv("Species.csv", function(data) {
		//pass array to locationSet
		speciesSet = data;
	});//end parsing "Species data"
	alert("Hello");
	var speciesOptions = []; 
	
	for(i = 0; i < speciesSet.length; i++){
		speciesOptions[i] = {id: i, text: speciesSet[i].species_name};
	}

	$(document).ready(function() {
		$(".slct1").select2({
		placeholder: "Select Species.",
		allowClear: true,
		data: speciesOptions, 
		});
		
		//DISPLAYING SPECIE INPUT WHEN 'GET VALUE' IS CLICKED                <----------------------------------
		$(".getValue").click(function() {
		input_specie= $(".slct1").val();									//SAVING INPUT AS A VALUE TYPE TO input_specie
		console.log("Specie: "+ input_specie);
		});
	});	
	
	$(document).ready(function() {
		$(".slct2").select2({
		placeholder: "Select Individual.",
		allowClear: true,
		data: speciesOptions,
		maximumSelectionLength: 3
		});
		
		//DISPLAYING INDIVIDUAL INPUT WHEN 'GET VALUE' IS CLICKED                <----------------------------------
		$(".getValue").click(function() {
		input_indiv= $(".slct2").val();										//SAVING INPUT AS A VALUE TYPE TO input_indiv
		console.log("Individual: "+ input_indiv);
		});

	});

	//radio button
	$(document).ready(function() {
		$("input:radio[name=radio_button]").click(function() {
			var checkval = $(this).val();
			$(".slct2").prop("disabled",(checkval == "0"));
			$(".slct2").select2("val", "");

		});
	});	
	
	//declare variables
	var start_date;
	var end_date;
	
	//Zebra_datepicker
	$(document).ready(function() {
	$("#startdate").Zebra_DatePicker();
	
	//DISPLAYING START DATE INPUT WHEN 'GET VALUE' IS CLICKED                <----------------------------------
	$("#generateBtn").click(function() {
	//SAVING START DATE INPUT											<------------------------------------
	start_date = new Date($("#startdate").val().concat("T00:00:00"));
	console.log("Start date: "+ start_date);
	console.log(typeof start_date);
		});

	});
	

	
	$(document).ready(function() {
	$("#enddate").Zebra_DatePicker();
	
	//DISPLAYING END DATE INPUT WHEN 'GET VALUE' IS CLICKED                <----------------------------------------
	$("#generateBtn").click(function() {
	//SAVING END DATE 													<--------------------------------------
	end_date = new Date($("#enddate").val().concat("T23:59:59"));
	console.log("End date: "+ end_date);
		});
	});
	
	//date validation
	if(end_date<start_date) {
		alert("EndDate have to be after StartDate");
	}
</script>

</head>
<body>
	
	<div id = "map">
		<script>
		
		L.mapbox.accessToken = 'pk.eyJ1IjoibWdsbW9udGVzIiwiYSI6ImNpbDhsZDV1YjBkNHd1MG0wd3Q3MnZpZmkifQ.6JR0V9EtTAhUeUi_tL4RJQ';
		var map = L.mapbox.map('map', 'mapbox.streets', {zoomControl: false})
			.setView([33.40, -118.20], 9);//37, -121, 6
			
			// Disable drag and zoom handlers.
			//map.dragging.disable();
			//map.touchZoom.disable();
			//map.doubleClickZoom.disable();
			//map.scrollWheelZoom.disable();
			//map.keyboard.disable();

			// Disable tap handler, if present.
			//if (map.tap) map.tap.disable();
			
						
		</script>
	</div>
	
	
	<div id="slider">
		<input type='range' min='0' max='6' step='1' value='0' id='rangeSlider' /> 
		<button type="button" id="start">start</button>
		<button type="button" id="stop">stop</button>
	</div>
	
	<div id = "input_section">
		<select class="slct1">
			<option></option>
		</select>
		
		<select class="slct2">
			<option></option>
		</select>
		
		<br>
		
		<input type="radio" name="radio_button" value="0" checked>All
		<input type="radio" name="radio_button" value="1">Individual
		
		<br>
		
		Start Date <div><input id="startdate" type="text"></div>
		End Date <div><input id="enddate" type="text"></div>
		
		<button type="button" id ="generateBtn">Generate</button>
	</div>

<script>	

const HOURLY = 3600000;
const DAILY = 86400000;
const WEEKLY = 604800000;
const MONTHLY = 2628000000;

    // Setup our svg layer that we can manipulate with d3
    var svg = d3.select(map.getPanes().overlayPane)
      .append("svg");
    //var g = svg.append("g").attr("class", "leaflet-zoom-hide");
	
	var bounds = map.getBounds();
	var topLeft = map.latLngToLayerPoint(bounds.getNorthWest())
	var bottomRight = map.latLngToLayerPoint(bounds.getSouthEast())
	svg.style("width", map.getSize().x + "px")
	  .style("height", map.getSize().y + "px")
	  .style("left", topLeft.x + "px")
	  .style("top", topLeft.y + "px");
	

	var allDetections = [];
    d3.csv("detections-1000data.csv", function(err, data) {
	
	for(i = 0; i < data.length; i++)
	{
		allDetections[i] = {lat: data[i].Latitude, lng: data[i].Longitude, trans: data[i].Transmitter, dateTime: data[i]["Date and Time (UTC)"].replace(/\s+/g, 'T'), dateTime: new Date(data[i]["Date and Time (UTC)"])};
	}
	
	console.log(allDetections.length);
	////START: data filtering////
	
	////END: data filtering////
	
	var startDate = allDetections[0].dateTime;
	var endDate = allDetections[allDetections.length-1].dateTime; 
	
	var startIndex = 0;
	var endIndex = 0;
	
	//determine starting index (for the allDetections array) based on startDate
	for(i = 0; i < allDetections.length; i++)
	{
		if(allDetections[i].dateTime.getTime() >= startDate.getTime())
		{
			startIndex = i; 
			break;
		}
	}
	
	//Determine ending index (for the allDetections array) based on endDate
	for(i = 0; i < allDetections.length; i++)
	{
		if(allDetections[i].dateTime.getTime() >= endDate.getTime())
		{
			endIndex = i; 
			break;
		}
	}
	
	var dots = [];
	var timeUnit = 3;//This value should be set based on user input 
	
	//selects time unit based on user input 
	switch(timeUnit)
	{
		case 0:
			dots = getHourlyDetections(startIndex, endIndex);
			break;
		case 1:
			dots = getDailyDetections(startIndex, endIndex);
			break;
		case 2: 
			dots = getWeeklyDetections(startIndex, endIndex);
			break; 
		case 3: 
			dots = getMonthlyDetections(startIndex, endIndex);
			break;
	}
	
	var circles = svg.selectAll("circle")
					.data(dots)
					.enter()
					.append("circle")	
					.attr("cx", function(d)
					{
						//if(d.tm === currentStep)
							return project(d).x;//simply use return project(d).x to display all (no if statement)
					})
					.attr("cy", function(d)
					{
						//if(d.tm === currentStep)
							return project(d).y;//simply use return project(d).y to display all (no if statement)
					})
					.style({
						fill: "#ff1a1a",
						"fill-opacity": 0.6,
						stroke: "#004d60",
						"stroke-width": 1
					})
					.attr("r", 2)


	
    function project(ll) 
	{
		var point = map.latLngToLayerPoint(L.latLng(ll))
		return point;	
    }
	
	//This function will make the detections for the current hour blink
	function drawDetections(currentStep){
		circles
		.attr("cx", function(d)
		{
			//if(d.tm === currentStep)
				return project(d).x;//simply use return project(d).x to display all (no if statement)
		})
		.attr("cy", function(d)
		{
			//if(d.tm === currentStep)
				return project(d).y;//simply use return project(d).y to display all (no if statement)
		})
		.style({
			fill: "#ff1a1a",
			"fill-opacity": 0.6,
			stroke: "#004d60",
			"stroke-width": 1
		})
		.transition().duration(500)
		.attr("r", function(d)
		{
			if(d.tm === currentStep)
				return d.rad;//simply use return d.rad to display all (no if statement)
			else
				return 2;
		})

		circles
		.transition().duration(500).delay(500)
		.attr("r", 2)
		
	}

	var myTimer;
	d3.select("#start").on("click", function() {
	 clearInterval (myTimer);
		myTimer = setInterval (function() {
			var b = d3.select("#rangeSlider");
			var t = (+b.property("value") + 1) % (+b.property("max") + 1);
			if (t == 0) { t = +b.property("min"); }
			b.property("value", t);
			drawDetections(t);
		}, 1000);
	});

	d3.select("#stop").on("click", function() {
		clearInterval (myTimer);
	});		
	
	});
	
	
	function getHourlyDetections(startIndex, endIndex)
	{
		var dots = [];
		var traversalIndex = startIndex;
		var timeMeasurement = 0;
		var currentTm = Math.floor(allDetections[startIndex].dateTime.getTime() / HOURLY);
	 
		dots[dots.length] = {lat: allDetections[startIndex].lat, lng: allDetections[startIndex].lng, rad: 7, tm: timeMeasurement};
		traversalIndex++;
		while(traversalIndex <= endIndex)
		{
			if(currentTm === Math.floor(allDetections[traversalIndex].dateTime.getTime() / HOURLY))
			{
				if(allDetections[traversalIndex].lat === dots[dots.length-1].lat && allDetections[traversalIndex].lng === dots[dots.length-1].lng)
				{
					dots[dots.length-1].rad += 5;
					traversalIndex++;
				}
				else
				{
					dots[dots.length] = {lat: allDetections[traversalIndex].lat, lng: allDetections[traversalIndex].lng, rad: 7, tm: timeMeasurement};
					traversalIndex++;
				}
			}
			else
			{
				timeMeasurement++;
				currentTm++;			
			}		
		}
		return dots;
	}

	function getDailyDetections(startIndex, endIndex)
	{
		var dots = [];
		var traversalIndex = startIndex;
		var timeMeasurement = 0;
		var currentTm = Math.floor(allDetections[startIndex].dateTime.getTime() / DAILY);
	 
		dots[dots.length] = {lat: allDetections[startIndex].lat, lng: allDetections[startIndex].lng, rad: 5, tm: timeMeasurement};
		while(traversalIndex <= endIndex)
		{
			if(currentTm === Math.floor(allDetections[traversalIndex].dateTime.getTime() / DAILY))
			{
				if(allDetections[traversalIndex].lat === dots[dots.length-1].lat && allDetections[traversalIndex].lng === dots[dots.length-1].lng)
				{
					dots[dots.length-1].rad += 30;
					traversalIndex++;
				}
				else
				{
					dots[dots.length] = {lat: allDetections[traversalIndex].lat, lng: allDetections[traversalIndex].lng, rad: 5, tm: timeMeasurement};
					traversalIndex++;
				}
			}
			else
			{
				timeMeasurement++;
				currentTm++;			
			}		
		}
		return dots;
	}

	function getWeeklyDetections(startIndex, endIndex)
	{
		var dots = [];
		var traversalIndex = startIndex;
		var timeMeasurement = 0;
		var currentTm = Math.floor(allDetections[startIndex].dateTime.getTime() / WEEKLY);
	 
		dots[dots.length] = {lat: allDetections[startIndex].lat, lng: allDetections[startIndex].lng, rad: 5, tm: timeMeasurement};
		while(traversalIndex <= endIndex)
		{
			if(currentTm === Math.floor(allDetections[traversalIndex].dateTime.getTime() / WEEKLY))
			{
				if(allDetections[traversalIndex].lat === dots[dots.length-1].lat && allDetections[traversalIndex].lng === dots[dots.length-1].lng)
				{
					dots[dots.length-1].rad += 1;
					traversalIndex++;
				}
				else
				{
					dots[dots.length] = {lat: allDetections[traversalIndex].lat, lng: allDetections[traversalIndex].lng, rad: 5, tm: timeMeasurement};
					traversalIndex++;
				}
			}
			else
			{
				timeMeasurement++;
				currentTm++;			
			}		
		}
		return dots;
	}
	
	function getMonthlyDetections(startIndex, endIndex)
	{
		var dots = [];
		var traversalIndex = startIndex;
		var timeMeasurement = 0;
		var currentTm = Math.floor(allDetections[startIndex].dateTime.getTime() / MONTHLY);
	 
		dots[dots.length] = {lat: allDetections[startIndex].lat, lng: allDetections[startIndex].lng, rad: 5, tm: timeMeasurement};
		while(traversalIndex <= endIndex)
		{
			if(currentTm === Math.floor(allDetections[traversalIndex].dateTime.getTime() / MONTHLY))
			{
				if(allDetections[traversalIndex].lat === dots[dots.length-1].lat && allDetections[traversalIndex].lng === dots[dots.length-1].lng)
				{
					dots[dots.length-1].rad += 1;
					traversalIndex++;
				}
				else
				{
					dots[dots.length] = {lat: allDetections[traversalIndex].lat, lng: allDetections[traversalIndex].lng, rad: 5, tm: timeMeasurement};
					traversalIndex++;
				}
			}
			else
			{
				timeMeasurement++;
				currentTm++;			
			}		
		}
		return dots;
	}

</script>
</body>
</html>
