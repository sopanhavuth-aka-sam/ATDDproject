<!doctype html>
<html lang="en">
<head>



	<meta charset="utf-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src='https://api.mapbox.com/mapbox.js/v2.2.3/mapbox.js'></script>
    <link href='https://api.mapbox.com/mapbox.js/v2.2.3/mapbox.css' rel='stylesheet' />

<style>
	#map { 
	position:absolute; 
	top:0;
	bottom:0; 
	width:100%; 
	}
	#slider{
		position: absolute;
	}
	
</style>

</head>
<body>
	
	<div id = "map">
		<script>
		
		L.mapbox.accessToken = 'pk.eyJ1IjoibWdsbW9udGVzIiwiYSI6ImNpbDhsZDV1YjBkNHd1MG0wd3Q3MnZpZmkifQ.6JR0V9EtTAhUeUi_tL4RJQ';
		var map = L.mapbox.map('map', 'mapbox.streets', {zoomControl: false})
			.setView([33.40, -118.20], 9);//37, -121, 6
			
			// Disable drag and zoom handlers.
			//map.dragging.disable();
			//map.touchZoom.disable();
			//map.doubleClickZoom.disable();
			//map.scrollWheelZoom.disable();
			//map.keyboard.disable();

			// Disable tap handler, if present.
			//if (map.tap) map.tap.disable();
			
						
		</script>
	</div>
	
	
	<div id="slider">
		<input type='range' min='0' max='6' step='1' value='0' id='rangeSlider' /> 
	<button type="button" id="start">start</button>
	<button type="button" id="stop">stop</button>
	</div>


<script>	

const HOURLY = 3600000;
const DAILY = 86400000;
const WEEKLY = 604800000;
const MONTHLY = 2628000000;

    // Setup our svg layer that we can manipulate with d3
    var svg = d3.select(map.getPanes().overlayPane)
      .append("svg");
    //var g = svg.append("g").attr("class", "leaflet-zoom-hide");
	
	var bounds = map.getBounds();
	var topLeft = map.latLngToLayerPoint(bounds.getNorthWest())
	var bottomRight = map.latLngToLayerPoint(bounds.getSouthEast())
	svg.style("width", map.getSize().x + "px")
	  .style("height", map.getSize().y + "px")
	  .style("left", topLeft.x + "px")
	  .style("top", topLeft.y + "px");
	

	var allDetections = [];
    d3.csv("phonieData.csv", function(err, data) {
	
	for(i = 0; i < data.length; i++)
	{
		allDetections[i] = {lat: data[i].Latitude, lng: data[i].Longitude, trans: data[i].Transmitter, dateTime: data[i]["Date and Time (UTC)"].replace(/\s+/g, 'T'), dateTime: new Date(data[i]["Date and Time (UTC)"])};
	}
	
	console.log(allDetections.length);
	
	var startDate = allDetections[0].dateTime;
	var endDate = allDetections[allDetections.length-1].dateTime; 
	
	var startIndex = 0;
	var endIndex = 0;
	
	//determine starting index (for the allDetections array) based on startDate
	for(i = 0; i < allDetections.length; i++)
	{
		if(allDetections[i].dateTime.getTime() >= startDate.getTime())
		{
			startIndex = i; 
			break;
		}
	}
	
	//Determine ending index (for the allDetections array) based on endDate
	for(i = 0; i < allDetections.length; i++)
	{
		if(allDetections[i].dateTime.getTime() >= endDate.getTime())
		{
			endIndex = i; 
			break;
		}
	}
	
	var dots = [];
	var timeUnit = 0;//This value should be set based on user input 
	
	//selects time unit based on user input 
	switch(timeUnit)
	{
		case 0:
			dots = getHourlyDetections(startIndex, endIndex);
			break;
		case 1:
			dots = getDailyDetections(startIndex, endIndex);
			break;
		case 2: 
			dots = getWeeklyDetections(startIndex, endIndex);
			break; 
		case 3: 
			dots = getMonthlyDetections(startIndex, endIndex);
			break;
	}
	
	console.log(dots.length);
	
	for(i = 0; i < dots.length; i++)
	{
		console.log(dots[i]);
	}
	
	var circles = svg.selectAll("circle")
					.data(dots)
					.enter()
					.append("circle")
					.attr("r", 0)	
	
    function project(ll) 
	{
		var point = map.latLngToLayerPoint(L.latLng(ll))
		return point;	
    }
	
	//This function will make the detections for the current hour blink
	function drawDetections(currentStep){
		circles
		.attr("cx", function(d)
		{
			//if(d.tm === currentStep)
				return project(d).x;//simply use return project(d).x to display all (no if statement)
		})
		.attr("cy", function(d)
		{
			//if(d.tm === currentStep)
				return project(d).y;//simply use return project(d).y to display all (no if statement)
		})
		.style({
			fill: "#ff1a1a",
			"fill-opacity": 0.6,
			stroke: "#004d60",
			"stroke-width": 1
		})
		.transition().duration(500)
		.attr("r", function(d)
		{
			//if(d.tm === currentStep)
				return d.rad;//simply use return d.rad to display all (no if statement)
		})

		circles
		.transition().duration(500).delay(500)
		.attr("r", 0)
		
	}

	var myTimer;
	d3.select("#start").on("click", function() {
	 clearInterval (myTimer);
		myTimer = setInterval (function() {
			var b = d3.select("#rangeSlider");
			var t = (+b.property("value") + 1) % (+b.property("max") + 1);
			if (t == 0) { t = +b.property("min"); }
			b.property("value", t);
			drawDetections(t);
		}, 1000);
	});

	d3.select("#stop").on("click", function() {
		clearInterval (myTimer);
	});		
	
	});
	
	
	function getHourlyDetections(startIndex, endIndex)
	{
		var dots = [];
		var traversalIndex = startIndex;
		var timeMeasurement = 0;
		var currentTm = Math.floor(allDetections[startIndex].dateTime.getTime() / HOURLY);
	 
		dots[dots.length] = {lat: allDetections[startIndex].lat, lng: allDetections[startIndex].lng, rad: 7, tm: timeMeasurement};
		traversalIndex++;
		while(traversalIndex <= endIndex)
		{
			if(currentTm === Math.floor(allDetections[traversalIndex].dateTime.getTime() / HOURLY))
			{
				if(allDetections[traversalIndex].lat === dots[dots.length-1].lat && allDetections[traversalIndex].lng === dots[dots.length-1].lng)
				{
					dots[dots.length-1].rad += 5;
					traversalIndex++;
				}
				else
				{
					dots[dots.length] = {lat: allDetections[traversalIndex].lat, lng: allDetections[traversalIndex].lng, rad: 7, tm: timeMeasurement};
					traversalIndex++;
				}
			}
			else
			{
				timeMeasurement++;
				currentTm++;			
			}		
		}
		return dots;
	}

	function getDailyDetections(startIndex, endIndex)
	{
		var dots = [];
		var traversalIndex = startIndex;
		var timeMeasurement = 0;
		var currentTm = Math.floor(allDetections[startIndex].dateTime.getTime() / DAILY);
	 
		dots[dots.length] = {lat: allDetections[startIndex].lat, lng: allDetections[startIndex].lng, rad: 5, tm: timeMeasurement};
		while(traversalIndex <= endIndex)
		{
			if(currentTm === Math.floor(allDetections[traversalIndex].dateTime.getTime() / DAILY))
			{
				if(allDetections[traversalIndex].lat === dots[dots.length-1].lat && allDetections[traversalIndex].lng === dots[dots.length-1].lng)
				{
					dots[dots.length-1].rad += 30;
					traversalIndex++;
				}
				else
				{
					dots[dots.length] = {lat: allDetections[traversalIndex].lat, lng: allDetections[traversalIndex].lng, rad: 5, tm: timeMeasurement};
					traversalIndex++;
				}
			}
			else
			{
				timeMeasurement++;
				currentTm++;			
			}		
		}
		return dots;
	}

	function getWeeklyDetections(startIndex, endIndex)
	{
		var dots = [];
		var traversalIndex = startIndex;
		var timeMeasurement = 0;
		var currentTm = Math.floor(allDetections[startIndex].dateTime.getTime() / WEEKLY);
	 
		dots[dots.length] = {lat: allDetections[startIndex].lat, lng: allDetections[startIndex].lng, rad: 5, tm: timeMeasurement};
		while(traversalIndex <= endIndex)
		{
			if(currentTm === Math.floor(allDetections[traversalIndex].dateTime.getTime() / WEEKLY))
			{
				if(allDetections[traversalIndex].lat === dots[dots.length-1].lat && allDetections[traversalIndex].lng === dots[dots.length-1].lng)
				{
					dots[dots.length-1].rad += 1;
					traversalIndex++;
				}
				else
				{
					dots[dots.length] = {lat: allDetections[traversalIndex].lat, lng: allDetections[traversalIndex].lng, rad: 5, tm: timeMeasurement};
					traversalIndex++;
				}
			}
			else
			{
				timeMeasurement++;
				currentTm++;			
			}		
		}
		return dots;
	}
	
	function getMonthlyDetections(startIndex, endIndex)
	{
		var dots = [];
		var traversalIndex = startIndex;
		var timeMeasurement = 0;
		var currentTm = Math.floor(allDetections[startIndex].dateTime.getTime() / MONTHLY);
	 
		dots[dots.length] = {lat: allDetections[startIndex].lat, lng: allDetections[startIndex].lng, rad: 5, tm: timeMeasurement};
		while(traversalIndex <= endIndex)
		{
			if(currentTm === Math.floor(allDetections[traversalIndex].dateTime.getTime() / MONTHLY))
			{
				if(allDetections[traversalIndex].lat === dots[dots.length-1].lat && allDetections[traversalIndex].lng === dots[dots.length-1].lng)
				{
					dots[dots.length-1].rad += 1;
					traversalIndex++;
				}
				else
				{
					dots[dots.length] = {lat: allDetections[traversalIndex].lat, lng: allDetections[traversalIndex].lng, rad: 5, tm: timeMeasurement};
					traversalIndex++;
				}
			}
			else
			{
				timeMeasurement++;
				currentTm++;			
			}		
		}
		return dots;
	}

</script>
</body>
</html>
