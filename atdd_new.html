<!doctype html>
<html lang="en">
<head>



	<meta charset="utf-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src='https://api.mapbox.com/mapbox.js/v2.2.3/mapbox.js'></script>
    <link href='https://api.mapbox.com/mapbox.js/v2.2.3/mapbox.css' rel='stylesheet' />
	
	<script src="jquery-2.2.3.min.js"></script>
	<link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.2/css/select2.min.css" rel="stylesheet" />
	<script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.2/js/select2.min.js"></script>
	<script src="Zebra_Datepicker-master/public/javascript/zebra_datepicker.js"></script>
	<link href="Zebra_Datepicker-master/public/css/default.css" rel="stylesheet">

<style>
	body
	{
		margin: 0;
		padding: 0;
	}

	#map 
	{ 
		position:absolute; 
		top:0;
		bottom:0; 
		width:75%; 
	}
	
	#slider{
		position: absolute;
	}
	
	#input_section
	{
		position: absolute;
		right: 0;
		background-color:#eeeeee;
		width:25%;
		height:60%;
		
	}
	
	#details
	{
		position: absolute;
		background-color: #a3a3c2;
		right: 0;
		bottom: 0;
		width: 25%;
		height: 40%; 	
		color: white;
		text-align: center;
	}
</style>

<script>

	//parsing "Species data" into an array of objects (row == object)
	d3.csv("Species.csv", function(data) {
		//pass array to locationSet
		speciesSet = data;
	});//end parsing "Species data"
	alert("Hello");
	var speciesOptions = []; 
	
	for(i = 0; i < speciesSet.length; i++){
		speciesOptions[i] = {id: i, text: speciesSet[i].species_name};
	}

	$(document).ready(function() {
		$(".slct1").select2({
		placeholder: "Select Species.",
		allowClear: true,
		data: speciesOptions, 
		});
	});	
	
	$(document).ready(function() {
		$(".slct2").select2({
		placeholder: "Select Individual.",
		allowClear: true,
		data: speciesOptions,
		maximumSelectionLength: 3
		});
	});

	/*
	//radio button
	$(document).ready(function() {
		$("input:radio[name=radio_button]").click(function() {
			var checkval = $(this).val();
			$(".slct2").prop("disabled",(checkval == "0"));
			$(".slct2").select2("val", "");

		});
	});	
	*/
	
	//Zebra_datepicker
	$(document).ready(function() {
		$("#startdate").Zebra_DatePicker();
	});
	
	$(document).ready(function() {
		$("#enddate").Zebra_DatePicker();
	});	
	
/*	
	$(document).ready(function() {
		$("input:radio[name=radio_button]").click(function() {
			var checkval = $(this).val();
			switch(checkval)
			{
				case "0":
					$("#timeLabel").text("hour");
					break;
				case "1": 
					$("#timeLabel").text("day");
					break;
				case "2": 
					$("#timeLabel").text("week");
					break;
				case "3": 
					$("#timeLabel").text("month");
					break;
			}

		});
	});
*/	


</script>

</head>
<body>
	
	<div id = "map">
		<script>
		
		L.mapbox.accessToken = 'pk.eyJ1IjoibWdsbW9udGVzIiwiYSI6ImNpbDhsZDV1YjBkNHd1MG0wd3Q3MnZpZmkifQ.6JR0V9EtTAhUeUi_tL4RJQ';
		var map = L.mapbox.map('map', 'mapbox.streets', {zoomControl: false})
			.setView([37.5, -120], 6);//33.40, -118.20
			
			// Disable drag and zoom handlers.
			map.dragging.disable();
			map.touchZoom.disable();
			map.doubleClickZoom.disable();
			map.scrollWheelZoom.disable();
			map.keyboard.disable();

			// Disable tap handler, if present.
			if (map.tap) map.tap.disable();
						
		</script>
	</div>
	
	<div id = "input_section">
		<select class="slct1">
			<option></option>
		</select>
		
		<select class="slct2">
			<option></option>
		</select>
		
		<br>
		
		<input type="radio" name="radio_button" value="0">Hourly
		<input type="radio" name="radio_button" value="1">Daily 
		<input type="radio" name="radio_button" value="2">Weekly 
		<input type="radio" name="radio_button" value="3">Monthly
		
		<br>
		
		Start Date <div><input id="startdate" type="text"></div>
		End Date <div><input id="enddate" type="text"></div>
		
		<br>
		<br>
		<br>
		
		<button id = "generate">Generate</button>
		
		<br>
		<br>
		<br>
		<br>
		
		<div id="slider">
			<input type='range' step = 1 value='0' id='rangeSlider' disabled /> 
			<button type="button" id="start" disabled>start</button>
			<button type="button" id="stop" disabled>stop</button><br>
			<!--Current <code id="timeLabel"></code>	: <code id="currentStep"></code>--->
		</div>
		
	</div>
	
	<div id="details">
		<h2>Details</h2>
		Date: <code id="date"></code><br>
		Time: <code id="time"></code><br>
		Latitude: <code id="lat"></code><br>
		Longitude: <code id="lng"></code>
	</div>

<script>
	const HOURLY = 3600000;
	const DAILY = 86400000;
	const WEEKLY = 604800000;
	const MONTHLY = 2628000000;
	
    // Setup our svg layer that we can manipulate with d3
    var svg = d3.select(map.getPanes().overlayPane)
      .append("svg");	
	  
	var bounds = map.getBounds();
	var topLeft = map.latLngToLayerPoint(bounds.getNorthWest())
	var bottomRight = map.latLngToLayerPoint(bounds.getSouthEast())
	svg.style("width", map.getSize().x + "px")
	  .style("height", map.getSize().y + "px")
	  .style("left", topLeft.x + "px")
	  .style("top", topLeft.y + "px");
	
	//Global variables---------------------------------------------------
	var allDetections = [];
	var circles;
	//-----------------------------------------------------------------------	

	//Event listener for the generate/clear button
	$("#generate").click(function() {
		$(this).text(function(i, v){
			if(v === "Generate")
			{

				if($(".slct1 option:selected").val() === "" || $("#startdate").val() === "" || $("#enddate").val() === ""){
					alert("Please fill out all fields.");
				}
			
				else
				{
					//startDate = new Date($("#startdate").val().concat("T00:00:00"));
					//endDate = new Date($("#enddate").val().concat("T23:59:59"));
					$("#start").prop('disabled', false);
					$("#stop").prop('disabled', false);
					var startDate = allDetections[0].dateTime;
					var endDate = allDetections[allDetections.length-1].dateTime;
			
					
					var p1 = new Promise(function(resolve, reject){
						var timeUnit = getTimeUnit();
						if(timeUnit >= 0 && timeUnit <= 3)
						{
							resolve(timeUnit);
						}
						else
						{
							reject(-1);
						}
					});
					
					
					///////////////////////////////////////////////////////////////////////////// Promise
					p1.then(function(value){
						return getDots(startDate, endDate, value);
					}).then(function(value){
						var sliderSteps = getSliderSteps(value);
						setSliderSteps(sliderSteps);
						return fitToScreen(value);
					}).then(function(value){
						setTimeout(function(){ initDetections(value); }, 300);
					})
					
					/*
					var timeUnit = getTimeUnit;
					var dots = getDots(startDate, endDate, timeUnit);
					fitToScreen(dots);
					setTimeout(function(){ initDetections(dots); }, 300);
					*/
					return "Clear"
					}
				}
				else if(v === "Clear")
				{
					$("#start").prop('disabled', true);
					$("#stop").prop('disabled', true);
					$("#rangeSlider").val("0");
					$("#date").text("");
					$("#time").text("");
					$("#lat").text("");
					$("#lng").text("");
					var sd = $("#startdate").data("Zebra_DatePicker");
					sd.clear_date();
					var ed = $("#enddate").data("Zebra_DatePicker");
					ed.clear_date();
					$(".slct1").select2("val", "");
					clearDetections();
					return "Generate"
			}
		});
	});	  
	
	function getSliderSteps(dots)
	{
		return dots[dots.length-1].tm;
	}
	
	function setSliderSteps(steps)
	{
		console.log(steps);
        $('#rangeSlider').prop({
            'min': 0,
            'max': steps
        });
	}
	
	
	function getTimeUnit()
	{
		var selection = document.getElementsByName("radio_button");
		var timeUnit = 0;
		for(var i = selection.length; i--;)
		{
			if(selection[i].checked)
			{
				timeUnit = selection[i].value;
			}
		}
		
		return Number(timeUnit); 
	}
	 
    d3.csv("phonieData.csv", function(err, data) {
		
		for(i = 0; i < data.length; i++)
		{
			allDetections[i] = {lat: data[i].Latitude, lng: data[i].Longitude, dateTime: data[i]["Date and Time (UTC)"].replace(/\s+/g, 'T'), dateTime: new Date(data[i]["Date and Time (UTC)"])};
		}	
	});
	
	/*
	* This function fills the dots array with detections based on the starting date and ending date. 
	* It then adds that data to the circles svg element to create cirlces from that data. The circles
	* are then displayed and blinked when the user clicks start.
	*/
	function initDetections(dots)
	{ 	
		circles = svg.selectAll("circle")
					.data(dots)
					.enter()
					.append("circle")	
					.attr("cx", function(d)
					{
						//if(d.tm === currentStep)
							return project(d).x;//simply use return project(d).x to display all (no if statement)
					})
					.attr("cy", function(d)
					{
						//if(d.tm === currentStep)
							return project(d).y;//simply use return project(d).y to display all (no if statement)
					})
					.style({
						fill: "#ff1a1a",
						"fill-opacity": 0.6,
						stroke: "#004d60",
						"stroke-width": 1
					})
					.attr("r", 2)
					.attr("id", function(d){
						return d.dateTime;
					})
	
		/*This function adds all the detections to the map with a radius of 2 and blinks 
		* detections based on the current step on the slider. 
		* @param currentStep The step that the slider is currently on. 
		*/
		function drawDetections(currentStep){
			circles
			.attr("cx", function(d)
			{
				return project(d).x;
			})
			.attr("cy", function(d)
			{
				return project(d).y;
			})
			.style({
				fill: "#ff1a1a",
				"fill-opacity": 0.6,
				stroke: "#004d60",
				"stroke-width": 1
			})
			.transition().duration(500)
			.attr("r", function(d)
			{
				if(d.tm === currentStep)
					return d.rad;
				else
					return 2;
			})			
		}

		/*Listener for the start button that moves the slider along and starts
		* the animation. 
		*/
		var myTimer;
		d3.select("#start").on("click", function() {
		 clearInterval (myTimer);
			myTimer = setInterval (function() {
				var b = d3.select("#rangeSlider");
				var t = (+b.property("value") + 1) % (+b.property("max") + 1);
				if (t == 0) { t = +b.property("min"); }
				b.property("value", t);
				drawDetections(t);
			}, 1000);
		});
		
		/*Listener for the stop button to stop the slider and 
		* stop the animation. 
		*/
		d3.select("#stop").on("click", function() {
			clearInterval (myTimer);
		});
		
		/*Listener to display information on the details section when the 
		* user hovers the cursor over a detection. 
		*/
		$(document).ready(function(){
			$("circle").mouseover(function(){
				$("#date").text(getDate(d3.select(this).attr("id")));
				$("#time").text(getTime(d3.select(this).attr("id")));
				$("#lat").text(getLat(d3.select(this).attr("cx"), d3.select(this).attr("cy")));
				$("#lng").text(getLng(d3.select(this).attr("cx"), d3.select(this).attr("cy")));
			});
		});
	}

	/* This function resizes the screen based on the detections. 
	*/
	function fitToScreen(dots)
	{
		map.fitBounds(dots);
		return dots;
	}
	
	/*This functions gets the latitude of a detection.
	*@param x This is the x coordinate of the detection. 
	*@param y This is the y coordiante of the detection. 
	*@return num This returns the latitude of the point on the map. 
	*/
	function getLat(x, y)
	{
		var point = map.containerPointToLatLng(L.point(x,y));
		return point.lat;
	}
	
	/*This functions gets the longitude of a detection.
	*@param x This is the x coordinate of the detection. 
	*@param y This is the y coordiante of the detection. 
	*@return num This returns the longitude of the point on the map. 
	*/
	function getLng(x, y)
	{
		var point = map.containerPointToLatLng(L.point(x,y));
		return point.lng;
	}
	
	/*This fuction gets the date of a detection. 
	* @param date The date object from a detection as a string. 
	* @return string This returns the date of the detection as a string. 
	*/
	function getDate(date)
	{
		var parse = date.split(" ", 4);
		var fixedDate = parse[0] + ", " + parse[1] + " " + parse[2] + " " + parse[3] + " ";  
		return fixedDate;
	}
	
	/*This fuction gets the time of a detection. 
	* @param date The date object from a detection as a string. 
	* @return string This returns the time of the detection as a string. 
	*/
	function getTime(date)
	{
		var parse = date.split(" ", 5);
		var fixedTime = parse[4];  
		return fixedTime;	
	}
	/* This function clears all the user inputs and removes the 
	*  detections from the map. 
	*/
	function clearDetections()
	{
		startDate = new Date();
		endDate = new Date(); 
		startIndex = 0;
		endIndex = 0;
		timeUnit = 0;
		dots = [];
		circles.remove();
	}

	/* This function returns a point based on latidude and longitude. 
	*  @param ll The longitude and longitude of a detection.
	*  @return num This returns the map layer point. 
	*/
    function project(ll) 
	{
		var point = map.latLngToLayerPoint(L.latLng(ll))
		return point;	
    }
	
	/*This fuction determines the index on which to start getting detections from the 
	* allDetections array to fill the dots array. 
	* @param allDetections The array containing all the detections from the csv file. 
	* @param startDate The starting date that the user entered. 
	* @return num The index on which to start adding detections to dots. 
	*/
	function getStartingIndex(allDetections, startDate)
	{
		var startIndex = 0;
		//determine starting index (for the allDetections array) based on startDate
		for(i = 0; i < allDetections.length; i++)
		{
			if(allDetections[i].dateTime.getTime() >= startDate.getTime())
			{
				startIndex = i; 
				break;
			}
		}
		return startIndex;
	}
	
	/*This fuction determines the index on which to stop getting detections from the 
	* allDetections array to fill the dots array. 
	* @param allDetections The array containing all the detections from the csv file. 
	* @param endDate The ending date that the user entered. 
	* @return num The index on which to stop adding detections to dots. 
	*/
	function getEndingIndex(allDetections, endDate)
	{
		var endIndex = 0;
		//Determine ending index (for the allDetections array) based on endDate
		for(i = 0; i < allDetections.length; i++)
		{
			if(allDetections[i].dateTime.getTime() >= endDate.getTime())
			{
				endIndex = i; 
				break;
			}
		}
		return endIndex;
	}
	
	/*This fuction determines how dots is to be filled based on the user 
	* time unit selection. 
	* @param startIndex The index on which to start adding detections from the allDetections array.
	* @param endIndex The index on which to stop adding detections from the alldDetections array.
	* @param timeUnit The time unit that the user has selected.
	* @return array This returns the detections to be displayed based on a unit of time. 
	*/
	function getDots(startDate, endDate, timeUnit)//timeUnit is based on user input, hourly, daily, etc.
	{
		var startIndex = getStartingIndex(allDetections, startDate);
		var endIndex = getEndingIndex(allDetections, endDate);
		
		var dots = [];
		switch(timeUnit)
		{
			case 0:
				dots = getHourlyDetections(startIndex, endIndex);
				break;
			case 1:
				dots = getDailyDetections(startIndex, endIndex);
				break;
			case 2: 
				dots = getWeeklyDetections(startIndex, endIndex);
				break; 
			case 3: 
				dots = getMonthlyDetections(startIndex, endIndex);
				break;
		}
		return dots;
	}
	
	/* This function fills the dots array based on an hourly detection rate. 
	* @param startIndex The index on which to start adding detections from the allDetections array.
	* @param endIndex The index on which to stop adding detections from the alldDetections array.
	* @return array This returns the detections to be displayed based on an hourly unit of time. 
	*/
	function getHourlyDetections(startIndex, endIndex)
	{
		var dots = [];
		var traversalIndex = startIndex;
		var timeMeasurement = 0;
		var currentTm = Math.floor(allDetections[startIndex].dateTime.getTime() / HOURLY);
	 
		dots[dots.length] = {lat: allDetections[startIndex].lat, lng: allDetections[startIndex].lng, rad: 7, dateTime: allDetections[startIndex].dateTime, tm: timeMeasurement};
		traversalIndex++;
		while(traversalIndex <= endIndex)
		{
			if(currentTm === Math.floor(allDetections[traversalIndex].dateTime.getTime() / HOURLY))
			{
				if(allDetections[traversalIndex].lat === dots[dots.length-1].lat && allDetections[traversalIndex].lng === dots[dots.length-1].lng)
				{
					dots[dots.length-1].rad += 5;
					traversalIndex++;
				}
				else
				{
					dots[dots.length] = {lat: allDetections[traversalIndex].lat, lng: allDetections[traversalIndex].lng, rad: 7, dateTime: allDetections[traversalIndex].dateTime, tm: timeMeasurement};
					traversalIndex++;
				}
			}
			else
			{
				timeMeasurement++;
				currentTm++;			
			}		
		}
		return dots;
	}

	/* This function fills the dots array based on an daily detection rate. 
	* @param startIndex The index on which to start adding detections from the allDetections array.
	* @param endIndex The index on which to stop adding detections from the alldDetections array.
	* @return array This returns the detections to be displayed based on an daily unit of time. 
	*/
	function getDailyDetections(startIndex, endIndex)
	{
		var dots = [];
		var traversalIndex = startIndex;
		var timeMeasurement = 0;
		var currentTm = Math.floor(allDetections[startIndex].dateTime.getTime() / DAILY);
	 
		dots[dots.length] = {lat: allDetections[startIndex].lat, lng: allDetections[startIndex].lng, rad: 5, tm: timeMeasurement};
		while(traversalIndex <= endIndex)
		{
			if(currentTm === Math.floor(allDetections[traversalIndex].dateTime.getTime() / DAILY))
			{
				if(allDetections[traversalIndex].lat === dots[dots.length-1].lat && allDetections[traversalIndex].lng === dots[dots.length-1].lng)
				{
					dots[dots.length-1].rad += 30;
					traversalIndex++;
				}
				else
				{
					dots[dots.length] = {lat: allDetections[traversalIndex].lat, lng: allDetections[traversalIndex].lng, rad: 5, tm: timeMeasurement};
					traversalIndex++;
				}
			}
			else
			{
				timeMeasurement++;
				currentTm++;			
			}		
		}
		return dots;
	}

	/* This function fills the dots array based on an weekly detection rate. 
	* @param startIndex The index on which to start adding detections from the allDetections array.
	* @param endIndex The index on which to stop adding detections from the alldDetections array.
	* @return array This returns the detections to be displayed based on an weekly unit of time. 
	*/
	function getWeeklyDetections(startIndex, endIndex)
	{
		var dots = [];
		var traversalIndex = startIndex;
		var timeMeasurement = 0;
		var currentTm = Math.floor(allDetections[startIndex].dateTime.getTime() / WEEKLY);
	 
		dots[dots.length] = {lat: allDetections[startIndex].lat, lng: allDetections[startIndex].lng, rad: 5, tm: timeMeasurement};
		while(traversalIndex <= endIndex)
		{
			if(currentTm === Math.floor(allDetections[traversalIndex].dateTime.getTime() / WEEKLY))
			{
				if(allDetections[traversalIndex].lat === dots[dots.length-1].lat && allDetections[traversalIndex].lng === dots[dots.length-1].lng)
				{
					dots[dots.length-1].rad += 1;
					traversalIndex++;
				}
				else
				{
					dots[dots.length] = {lat: allDetections[traversalIndex].lat, lng: allDetections[traversalIndex].lng, rad: 5, tm: timeMeasurement};
					traversalIndex++;
				}
			}
			else
			{
				timeMeasurement++;
				currentTm++;			
			}		
		}
		return dots;
	}

	/* This function fills the dots array based on an monthly detection rate. 
	* @param startIndex The index on which to start adding detections from the allDetections array.
	* @param endIndex The index on which to stop adding detections from the alldDetections array.
	* @return array This returns the detections to be displayed based on an monthly unit of time. 
	*/
	function getMonthlyDetections(startIndex, endIndex)
	{
		var dots = [];
		var traversalIndex = startIndex;
		var timeMeasurement = 0;
		var currentTm = Math.floor(allDetections[startIndex].dateTime.getTime() / MONTHLY);
	 
		dots[dots.length] = {lat: allDetections[startIndex].lat, lng: allDetections[startIndex].lng, rad: 5, tm: timeMeasurement};
		while(traversalIndex <= endIndex)
		{
			if(currentTm === Math.floor(allDetections[traversalIndex].dateTime.getTime() / MONTHLY))
			{
				if(allDetections[traversalIndex].lat === dots[dots.length-1].lat && allDetections[traversalIndex].lng === dots[dots.length-1].lng)
				{
					dots[dots.length-1].rad += 1;
					traversalIndex++;
				}
				else
				{
					dots[dots.length] = {lat: allDetections[traversalIndex].lat, lng: allDetections[traversalIndex].lng, rad: 5, tm: timeMeasurement};
					traversalIndex++;
				}
			}
			else
			{
				timeMeasurement++;
				currentTm++;			
			}		
		}
		return dots;
	}

</script>
</body>
</html>