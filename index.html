<!DOCTYPE html>
<html>
	<head>
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
	<meta content="utf-8" http-equiv="encoding">

		<title>SharkLab ATDD</title>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>

		<script src="js/jquery-2.2.3.min.js"></script>

		<script type='text/javascript' src='atddScript.js'></script>
		<link rel='stylesheet' type='text/css' href='atddStylesheet.css'/>


		<script src='https://api.mapbox.com/mapbox.js/v2.3.0/mapbox.js'></script>
		<link href='https://api.mapbox.com/mapbox.js/v2.3.0/mapbox.css' rel='stylesheet' />

		<link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.2/css/select2.min.css" rel="stylesheet" />
		<script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.2/js/select2.min.js"></script>

		<script src="Zebra_Datepicker-master/public/javascript/zebra_datepicker.js"></script>
		<link href="Zebra_Datepicker-master/public/css/metallic.css" rel="stylesheet">

		<script src="xdate.js"></script>

		<!-- All of the funcitons required to getDetections. -->
		<script type='text/javascript' src='getDetections.js'></script>
	</head>

	<body>

		<div class = "container">

			<div id = "map">

				<script>
					L.mapbox.accessToken = 'pk.eyJ1IjoibWdsbW9udGVzIiwiYSI6ImNpbDhsZDV1YjBkNHd1MG0wd3Q3MnZpZmkifQ.6JR0V9EtTAhUeUi_tL4RJQ';

					var map = L.mapbox.map('map', 'mapbox.streets', {zoomControl: false}).setView([37.5, -120], 6); // 33.40, -118.20 -> (other view tried from last semester)

						// Disable drag and zoom handlers.
						map.dragging.disable();
						map.touchZoom.disable();
						map.doubleClickZoom.disable();
						map.scrollWheelZoom.disable();
						map.keyboard.disable();

						// Disable tap handler, if present.
						if (map.tap) map.tap.disable();
				</script>

			</div>

			<div id="navBar">
				<div id = "trackButton"><h3>Track</h3></div>
				<!--<div id = "logo"><h3>CSULB SharkLab</h3></div>-->
				<a href="https://www.csulb.edu/natural-sciences-mathematics-biological-sciences/explore/shark-lab"><img src="sharkLabMod.png" alt="sbLogo" id = "logo"></a>
				<div id = "detailsButton"><h3>User Guide</h3></div>
				<!--<a href="#" onclick = "window.open(file:///C:/Users/Miguel/Dropbox/CECS491/practice/UserGuide.html">Guide</a>-->
			</div>

			<div id="trackMenu" class="initiallyHidden">

				<ul id = "myTable">

					<li class = "items"><span class = "itemsSpan">
						<select id="speciesSlct">
							<option></option>
						</select>
					</span></li>

					<li class = "items"><span class = "itemsSpan">
						<select id="individualSlct">
							<option></option>
						</select>
					</span></li>

					<li class = "items"><span class = "itemsSpan">
						<div class="menuItem" id="radioContainer">
							<label class="radioLabel"><input type="radio" name="radioButton" value = "0"><span>Hourly</span></label>
							<label class="radioLabel"><input type="radio" name="radioButton" value = "1"><span>Daily</span></label>
							<label class="radioLabel"><input type="radio" name="radioButton" value = "2"><span>Weekly</span></label>
							<label class="radioLabel"><input type="radio" name="radioButton" value = "3"><span>Monthly</span></label>
						</div>
					</span></li>

					<li class = "items"><span class = "itemsSpan">
						Start Date <div><input id="startdate" type="text"></div>
					</span></li>

					<li class = "items"><span class = "itemsSpan">
						End Date <div><input id="enddate" type="text"></div>
					</span></li>

					<li class = "items"><span class = "itemsSpan">
						<button	class="button" id = "generate">Generate</button>
					</span></li>
				</ul>

			</div>

			<div id="sliderBox">
				<input type='range' step = 1 value='0' id='rangeSlider' disabled />
				<button id="play" disabled>Play</button>
				<div id="dateTag">
					<code id="currentDate"></code><br>
					<code id="currentHour"></code>
				</div>
			</div>

			<div id="details">
				Date: <code id="date"></code><br>
				Time: <code id="time"></code><br>
				Latitude: <code id="lat"></code><br>
				Longitude: <code id="lng"></code>
			</div>

		</div>


		<script>
			// start javascript

			// constants
			const HOURLY = 3600000;
			const DAILY = 86400000;
			const WEEKLY = 604800000;
			const MONTHLY = 2628000000;

			// Setup svg layer that we can manipulate with d3
			var svg = d3.select(map.getPanes().overlayPane).append("svg");

			var bounds = map.getBounds();
			var topLeft = map.latLngToLayerPoint(bounds.getNorthWest())
			var bottomRight = map.latLngToLayerPoint(bounds.getSouthEast())
				svg.style("width", map.getSize().x + "px")
				.style("height", map.getSize().y + "px")
				.style("left", topLeft.x + "px")
				.style("top", topLeft.y + "px");

			//Global variables---------------------------------------------------
			var allDetections = []; //instead of storing all detection, store server response.
			var circles;

			//-----------------------------------------------------------------------
			// Event listener for the generate/clear button in the track menu
			$("#generate").click(function() {
				$(this).text(function(i, v) {
					// button text == Generate
					if(v === "Generate") {
						// verify all required fields in track menu are filled out
						if($("#speciesSlct option:selected").val() === "" || $("#startdate").val() === "" || $("#enddate").val() === "" || ($('input[type=radio]:checked').size() > 0) === false){
							alert("Please fill out all fields.");
						}
						else {
							// get start and end date from date pickers
							var startDate = new Date($("#startdate").val().concat("T00:00:00"));
							var endDate = new Date($("#enddate").val().concat("T00:00:00"));

							$("#play").prop('disabled', false);

							// promise represents a value that may be available now, in the future or never
							var p1 = new Promise(function(resolve, reject) {
								var timeUnit = getTimeUnit();
								if(timeUnit >= 0 && timeUnit <= 3) {
									resolve(timeUnit);
								}
								else {
									reject(-1);
								}
							});

							// uses promise object and value, value == timeUnits
							p1.then(function(value) {
								var dots = getDots(startDate, endDate, value);
								if(dots.length === 0) {
									$("#start").prop('disabled', true);
									$("#stop").prop('disabled', true);
									alert("There's no detections within the selected time period.");
									return dots;
								}
								return dots;
							}).then(function(value) { // uses return value of above function, value == dots
								if(value.length === 0) {
									return value;
								}
								else {
									var sliderSteps = getSliderSteps(value);
									setSliderSteps(sliderSteps);
									return fitToScreen(value);
								}
							}).then(function(value) {
								if(value.length === 0) {
									$("#generate").text("Generate");
								}
								else {
									var timeUnit = getTimeUnit();
									$("#generate").text("Clear");
									setTimeout(function(){ initDetections(value, timeUnit); }, 300);
								}
							});
							$("#trackMenu").toggle("slow");
						}
					}
					// button text == Clear
					// reset UI, clear text, clear detection dots from map
					else if(v === "Clear") {
						$("#play").text("Play");
						d3.select("#play").on("click", function() {
							clearInterval(myTimer);
						});
						$("#play").prop('disabled', true);
						$("#rangeSlider").val("0");
						$("#date").text("");
						$("#time").text("");
						$("#lat").text("");
						$("#lng").text("");
						$("#currentDate").text("");
						$("#currentHour").text("");
						var sd = $("#startdate").data("Zebra_DatePicker");
						sd.clear_date();
						var ed = $("#enddate").data("Zebra_DatePicker");
						ed.clear_date();
						$("#speciesSlct").select2("val", "");
						clearDetections();
						return "Generate"
					}
				});
			});

			/* Gets the number of steps for the slider
			* @param dots, array of user desired detections
			* @return size of dots array
			*/
			function getSliderSteps(dots)
			{
				return dots[dots.length-1].tm;
			}

			/* Sets the number of steps for the slider
			* @param steps, number of steps to use for slider
			*/
			function setSliderSteps(steps)
			{
				$('#rangeSlider').prop({
					'min': 0,
					'max': steps
				});
			}

			/* Gets the time unit selected by user from track menu radio buttons
			*		(hourly, daily, weekly, monthly)
			* @return the index of the selected button
			*/
			function getTimeUnit()
			{
				var selection = document.getElementsByName("radioButton");
				var timeUnit = 0;
				for(var i = selection.length; i--;) {
					if(selection[i].checked) {
						timeUnit = selection[i].value;
					}
				}
				return Number(timeUnit);
			}

			/* Imports all data from .csv file with the detections data
			* @param string, file name
			* Parse data from .csv file into allDetections array
			*/
			d3.csv("JWS_20150914_export.csv", function(err, data) {
				for(i = 0; i < data.length; i++) {
					//use library XDate to help convert date; [0] is needed because otherwise 'date object' is inside an array of object.
					allDetections[i] = {lat: data[i].Latitude, lng: data[i].Longitude, dateTime: (new XDate (data[i]["Date and Time (UTC)"].replace(/\s+/g, 'T'), true))[0]};
				}
				console.log("parsing completed");
			});

			/*
			* This function fills the dots array with detections based on the starting date and ending date.
			* It then adds that data to the circles svg element to create cirlces from that data.
			* The circles are then displayed and blinked when the user clicks play.
			*/
			function initDetections(dots, timeUnit) {
				//d3
				circles = svg.selectAll("circle")
						.data(dots)
						.enter()
						.append("circle")
						.attr("cx", function(d)
						{
								return project(d).x; // simply use return project(d).x to display all
						})
						.attr("cy", function(d)
						{
								return project(d).y; // simply use return project(d).y to display all
						})
						.style({
							fill: "#ff1a1a",
							"fill-opacity": 0.6,
							stroke: "#004d60",
							"stroke-width": 1
						})
						.attr("r", 2)
						.attr("id", function(d){
							return d.dateTime;
						})

				/* Sets the date tag text (date and hour) based on current step
				* @param current step, index of dots array that the slider is currently on
				*/
				function dateTag(currentStep)
				{
					if(timeUnit === 0) {
						$("#currentHour").text(getSliderHour(dots, currentStep))
					}
					else {
						$("#currentDate").text(getSliderDate(dots, currentStep));
					}
				}

				/* Adds all the detections to the map with a radius of 2 and blinks
				* detections based on the current step on the slider
				* @param currentStep, index of dots array that the slider is currently on
				*/
				function drawDetections(currentStep) {
					// add this to fixed the circle size
					var max_rad = $(window).height() * 0.15;//dynamcially change base on screen size
					var maxDetectionCount = Math.max.apply(Math,dots.map(function(o){
													return o.count;
												})); // maximum detection at a single location/dot

					circles
					.attr("cx", function(d)
					{
						return project(d).x;
					})
					.attr("cy", function(d)
					{
						return project(d).y;
					})
					.style({
						fill: "#ff1a1a",
						"fill-opacity": 0.6,
						stroke: "#004d60",
						"stroke-width": 1
					})
					.transition().duration(500)
					.attr("r", function(d)
					{
						if(d.tm === currentStep)
							// return d.rad;//simply use return d.rad to display all (no if statement)
							return d.count * max_rad / maxDetectionCount;
						else
							return 2;
					})
				}

				/* play button clicked
				* 	when play button is clicked:
				*	draw detections on map and set date tag based on current step in slider
				*/
				var myTimer;
				d3.select("#play").on("click", function() {

					if (d3.select("#play").text() === "Play") {
						 clearInterval(myTimer);
							myTimer = setInterval (function() {
								var b = d3.select("#rangeSlider");
								var t = (+b.property("value") + 1) % (+b.property("max") + 1);
								if (t == 0) {
									t = +b.property("min");
								}
								b.property("value", t);
								drawDetections(t);
								dateTag(t);
							}, 1000);
						d3.select("#play").text("Pause");
					}
					else if (d3.select("#play").text() === "Pause") {
						clearInterval (myTimer);
						d3.select("#play").text("Play");
					}
				});

				/* Listener to display information on the details section when the
				* 	user hovers the cursor over a detection
				*/
				$(document).ready(function(){
					$("circle").mouseover(function(){
						$("#date").text(getDate(d3.select(this).attr("id")));
						$("#time").text(getTime(d3.select(this).attr("id")));
						$("#lat").text(getLat(d3.select(this).attr("cx"), d3.select(this).attr("cy")));
						$("#lng").text(getLng(d3.select(this).attr("cx"), d3.select(this).attr("cy")));
					});
				});

				/* Displays detection information when hovering over a detection
				* 	(date, time, lat, long)
				*/
				$(function(){
					$("circle").hover(function(e) {
						$("#date").text(getDate(d3.select(this).attr("id")));
						$("#time").text(getTime(d3.select(this).attr("id")));
						$("#lat").text(getLat(d3.select(this).attr("cx"), d3.select(this).attr("cy")));
						$("#lng").text(getLng(d3.select(this).attr("cx"), d3.select(this).attr("cy")));
						$("#details").show()
							.css('top', e.pageY)
							.css('left', e.pageX)
							.appendTo("body");
					}, function() {
						$("#details").hide();
					});
				});

			}

			// Cherie starts commenting here. Matt stop.

			/*
			* This method given the array of dots that
			* currentStep is the index. A portion of the play line.
			* /@param: dots is the array that has the user's queryed dots in it.
			* Used at the dot if you hover over it displays the Date, location, time of detection.
			*/
			function getSliderDate(dots, currentStep)
			{
				var day = dots[currentStep].dateTime.getDate();
				var month = dots[currentStep].dateTime.getMonth() + 1;
				var year = dots[currentStep].dateTime.getFullYear();
				var date = "Date:" + month.toString() + "/" + day.toString() + "/" + year.toString();
				return date;
			}

			/*Called from DateTag.
				Displayed on the top corner right.
				@return: It returns the string that it will display in the small box in the top right
					corner of the play box(made with js and css).
			*/

			function getSliderHour(dots, currentStep)
			{
				var hour = dots[currentStep].dateTime.getHours();
				var time = "";
				if (hour == 0 || hour == 24)
				{
					time = "Time:12:00 am."
				}
				else if(hour <= 12)
				{
					time = "Time:" + hour + ":00 am."
				}
				else if(hour > 12)
				{
					time = "Time:" + hour%12 + ":00 pm."
				}
				return time;
			}

			/* This function resizes the screen based on the detections.
			* map is the mapbox library/api object.
			*/
			function fitToScreen(dots)
			{
				map.fitBounds(dots); //calls the mapbox mqp object.
				return dots;
			}

			/*This functions gets the latitude of a detection.
			*@param x This is the x coordinate of the detection.
			*@param y This is the y coordiante of the detection.
			*@return num This returns the latitude of the point on the map.
			*/
			function getLat(x, y)
			{
				var point = map.containerPointToLatLng(L.point(x,y));
				return point.lat.toFixed(5);
			}

			/*This functions gets the longitude of a detection.
			*@param x This is the x coordinate of the detection.
			*@param y This is the y coordiante of the detection.
			*@return num This returns the longitude of the point on the map.
			*/
			function getLng(x, y)
			{
				var point = map.containerPointToLatLng(L.point(x,y));
				return point.lng.toFixed(5);
			}

			/*This fuction gets the date of a detection.
			* @param date The date object from a detection as a string.
			* @return string This returns the date of the detection as a string.
			*/
			function getDate(date)
			{
				var parse = date.split(" ", 4);
				var fixedDate = parse[0] +  parse[2] + " " + parse[1] + " " + parse[3] + " ";
				return fixedDate;
			}

			/*This fuction gets the time of a detection.
			* @param date The date object from a detection as a string.
			* @return string This returns the time of the detection as a string.
			*/
			function getTime(date)
			{
				var parse = date.split(" ", 5);
				var fixedTime = parse[4];
				return fixedTime;
			}
			/* This function clears all the user inputs and removes the
			*  detections from the map.
			*/
			function clearDetections()
			{
				startDate = new Date();
				endDate = new Date();
				startIndex = 0;
				endIndex = 0;
				timeUnit = 0;
				dots = [];
				circles.remove();
			}
			/* This function returns a point based on latidude and longitude.
			*  @param ll The longitude and longitude of a detection.
			*  @return num This returns the map layer point.
			*/
			function project(ll)
			{
				var point = map.latLngToLayerPoint(L.latLng(ll))
				return point;
			}

			/*This fuction determines the index on which to start getting detections from the
			* allDetections array to fill the dots array.
			* @param allDetections The array containing all the detections from the csv file.
			* @param startDate The starting date that the user entered.
			* @return num The index on which to start adding detections to dots.
			*/
			function getStartingIndex(allDetections, startDate)
			{
				var startIndex = -1;
				//determine starting index (for the allDetections array) based on startDate
				for(i = 0; i < allDetections.length; i++)
				{
					if(allDetections[i].dateTime.getTime() >= startDate.getTime())
					{
						startIndex = i;
						break;
					}
				}
				return startIndex;
			}

			/*This fuction determines the index on which to stop getting detections from the
			* allDetections array to fill the dots array.
			* @param allDetections The array containing all the detections from the csv file.
			* @param endDate The ending date that the user entered.
			* @return num The index on which to stop adding detections to dots.
			*/
			function getEndingIndex(allDetections, endDate)
			{
				var endIndex = 0;
				//Determine ending index (for the allDetections array) based on endDate
				for(i = 0; i < allDetections.length; i++)
				{
					if(allDetections[i].dateTime.getTime() > endDate.getTime())
					{
						endIndex = i - 1;
						break;
					}
				}
				return endIndex;
			}

			/*This fuction determines how dots is to be filled based on the user
			* time unit selection.
			* @param startIndex The index on which to start adding detections from the allDetections array.
			* @param endIndex The index on which to stop adding detections from the alldDetections array.
			* @param timeUnit The time unit that the user has selected.
			* @return array This returns the detections to be displayed based on a unit of time in an array called dots
			*/
			function getDots(startDate, endDate, timeUnit)//timeUnit is based on user input, hourly, daily, etc.
			{
				var startIndex = getStartingIndex(allDetections, startDate);
				var endIndex = getEndingIndex(allDetections, endDate);

				//console.log(startIndex + "  " + endIndex); //DEBUGGING
				//console.log(startDate + " " + endDate); //DEBUGGING
				var dots = [];

				if(startIndex === -1) {
					return dots;
				}

				switch(timeUnit)
				{
					case 0:
						dots = getHourlyDetections(startIndex, endIndex);
						break;
					case 1:
						dots = getDailyDetections(startIndex, endIndex);
						break;
					case 2:
						dots = getWeeklyDetections(startIndex, endIndex);
						break;
					case 3:
						dots = getMonthlyDetections(startIndex, endIndex);
						break;
				}
				return dots;
			}

			/* This function fills the dots array based on an hourly detection rate.
			* @param startIndex The index on which to start adding detections from the allDetections array.
			* @param endIndex The index on which to stop adding detections from the alldDetections array.
			* @return array This returns the detections to be displayed based on an hourly unit of time.
			*/
			function getHourlyDetections(startIndex, endIndex)
			{
				var dots = [];
				var traversalIndex = startIndex;
				var timeMeasurement = 0;
				var currentTm = Math.floor(allDetections[startIndex].dateTime.getTime() / HOURLY);
				var uniqueDotsInTm = 0;

				dots[dots.length] = {lat: allDetections[startIndex].lat, lng: allDetections[startIndex].lng, count: 1, tm: timeMeasurement, dateTime: allDetections[traversalIndex].dateTime};
				uniqueDotsInTm++;
				while(traversalIndex <= endIndex)
				{
					if(currentTm === Math.floor(allDetections[traversalIndex].dateTime.getTime() / HOURLY))
					{
						if(allDetections[traversalIndex].lat === dots[dots.length-1].lat && allDetections[traversalIndex].lng === dots[dots.length-1].lng
							&& timeMeasurement === dots[dots.length-1].tm)
						{
							dots[dots.length-1].count += 1;
							traversalIndex++;
						}
						else
						{
							var newDot = true;
							for(i=uniqueDotsInTm; i > 0; i--) {
								if(allDetections[traversalIndex].lat === dots[dots.length-i].lat && allDetections[traversalIndex].lng === dots[dots.length-i].lng) {
									dots[dots.length-i].count += 1;
									newDot = false;
								}
							}
							if(newDot) {
								dots[dots.length] = {lat: allDetections[traversalIndex].lat, lng: allDetections[traversalIndex].lng, count: 1, tm: timeMeasurement, dateTime: allDetections[traversalIndex].dateTime};
								uniqueDotsInTm++;
							}

							traversalIndex++;
						}
					}
					else
					{
						timeMeasurement++;
						currentTm = Math.floor(allDetections[traversalIndex].dateTime.getTime() / HOURLY);
						uniqueDotsInTm = 0;
					}
				}
				return dots;
			}
			/* This function fills the dots array based on an daily detection rate.
			* @param startIndex The index on which to start adding detections from the allDetections array.
			* @param endIndex The index on which to stop adding detections from the alldDetections array.
			* @return array This returns the detections to be displayed based on an daily unit of time.
			*/
			function getDailyDetections(startIndex, endIndex)
			{
				var dots = []; //dots where trackers are activated.
				var traversalIndex = startIndex;
				var timeMeasurement = 0;
				var currentTm = Math.floor(allDetections[startIndex].dateTime.getTime() / DAILY);
				var uniqueDotsInTm = 0;

				dots[dots.length] = {lat: allDetections[startIndex].lat, lng: allDetections[startIndex].lng, count: 1, tm: timeMeasurement, dateTime: allDetections[traversalIndex].dateTime};
				uniqueDotsInTm++;
				while(traversalIndex <= endIndex)
				{
					if(currentTm === Math.floor(allDetections[traversalIndex].dateTime.getTime() / DAILY))
					{
						if(allDetections[traversalIndex].lat === dots[dots.length-1].lat && allDetections[traversalIndex].lng === dots[dots.length-1].lng
							&& timeMeasurement === dots[dots.length-1].tm)
						{
							dots[dots.length-1].count += 1;
							traversalIndex++;
						}
						else
						{
							var newDot = true;
							for(i=uniqueDotsInTm; i > 0; i--) {
								if(allDetections[traversalIndex].lat === dots[dots.length-i].lat && allDetections[traversalIndex].lng === dots[dots.length-i].lng) {
									dots[dots.length-i].count += 1;
									newDot = false;
								}
							}
							if(newDot) {
								dots[dots.length] = {lat: allDetections[traversalIndex].lat, lng: allDetections[traversalIndex].lng, count: 1, tm: timeMeasurement, dateTime: allDetections[traversalIndex].dateTime};
								uniqueDotsInTm++;
							}

							traversalIndex++;
						}
					}
					else
					{
						timeMeasurement++;
						currentTm = Math.floor(allDetections[traversalIndex].dateTime.getTime() / DAILY);
						uniqueDotsInTm = 0;
					}
				}
				return dots;
			}
			/* This function fills the dots array based on an weekly detection rate.
			* @param startIndex The index on which to start adding detections from the allDetections array.
			* @param endIndex The index on which to stop adding detections from the alldDetections array.
			* @return array This returns the detections to be displayed based on an weekly unit of time.
			*/
			function getWeeklyDetections(startIndex, endIndex)
			{
				var dots = [];
				var traversalIndex = startIndex;
				var timeMeasurement = 0;
				var currentTm = Math.floor(allDetections[startIndex].dateTime.getTime() / WEEKLY);
				var uniqueDotsInTm = 0;

				dots[dots.length] = {lat: allDetections[startIndex].lat, lng: allDetections[startIndex].lng, count: 1, tm: timeMeasurement, dateTime: allDetections[traversalIndex].dateTime};
				uniqueDotsInTm++;
				while(traversalIndex <= endIndex)
				{
					if(currentTm === Math.floor(allDetections[traversalIndex].dateTime.getTime() / WEEKLY))
					{
						if(allDetections[traversalIndex].lat === dots[dots.length-1].lat && allDetections[traversalIndex].lng === dots[dots.length-1].lng
							&& timeMeasurement === dots[dots.length-1].tm)
						{
							dots[dots.length-1].count += 1;
							traversalIndex++;
						}
						else
						{
							var newDot = true;
							for(i=uniqueDotsInTm; i > 0; i--) {
								if(allDetections[traversalIndex].lat === dots[dots.length-i].lat && allDetections[traversalIndex].lng === dots[dots.length-i].lng) {
									dots[dots.length-i].count += 1;
									newDot = false;
								}
							}
							if(newDot) {
								dots[dots.length] = {lat: allDetections[traversalIndex].lat, lng: allDetections[traversalIndex].lng, count: 1, tm: timeMeasurement, dateTime: allDetections[traversalIndex].dateTime};
								uniqueDotsInTm++;
							}

							traversalIndex++;
						}
					}
					else
					{
						timeMeasurement++;
						currentTm = Math.floor(allDetections[traversalIndex].dateTime.getTime() / WEEKLY);
						uniqueDotsInTm = 0;
					}
				}
				return dots;
			}
			/* This function fills the dots array based on an monthly detection rate.
			* @param startIndex The index on which to start adding detections from the allDetections array.
			* @param endIndex The index on which to stop adding detections from the alldDetections array.
			* @return array This returns the detections to be displayed based on an monthly unit of time.
			*/
			function getMonthlyDetections(startIndex, endIndex)
			{
		var dots = [];
				var traversalIndex = startIndex;
				var timeMeasurement = 0;
				var currentTm = Math.floor(allDetections[startIndex].dateTime.getTime() / MONTHLY);
				var uniqueDotsInTm = 0;

				dots[dots.length] = {lat: allDetections[startIndex].lat, lng: allDetections[startIndex].lng, count: 1, tm: timeMeasurement, dateTime: allDetections[traversalIndex].dateTime};
				uniqueDotsInTm++;
				while(traversalIndex <= endIndex)
				{
					if(currentTm === Math.floor(allDetections[traversalIndex].dateTime.getTime() / MONTHLY))
					{
						if(allDetections[traversalIndex].lat === dots[dots.length-1].lat && allDetections[traversalIndex].lng === dots[dots.length-1].lng
							&& timeMeasurement === dots[dots.length-1].tm)
						{
							dots[dots.length-1].count += 1;
							traversalIndex++;
						}
						else
						{
							var newDot = true;
							for(i=uniqueDotsInTm; i > 0; i--) {
								if(allDetections[traversalIndex].lat === dots[dots.length-i].lat && allDetections[traversalIndex].lng === dots[dots.length-i].lng) {
									dots[dots.length-i].count += 1;
									newDot = false;
								}
							}
							if(newDot) {
								dots[dots.length] = {lat: allDetections[traversalIndex].lat, lng: allDetections[traversalIndex].lng, count: 1, tm: timeMeasurement, dateTime: allDetections[traversalIndex].dateTime};
								uniqueDotsInTm++;
							}

							traversalIndex++;
						}
					}
					else
					{
						timeMeasurement++;
						currentTm = Math.floor(allDetections[traversalIndex].dateTime.getTime() / MONTHLY);
						uniqueDotsInTm = 0;
					}
				}
				return dots;
			}

			//Might not need this
			//filering data base on userInput(dates)
		//	function dateFilter(data, start_date, end_date) {
		//
		//		var newData = [];
		//
		//		for(i =0; i < data.length - 1; i++) {
		//			if( +start_date <= +data[i].dateTime && +data[i].dateTime <= +end_date) {
		//				newData.push(data[i]);
		//			}
		//		}
		//
		//		return newData;
		//	}//end: dateFilter()

			function removeZeroCountDot(dots) {
				var noZeroDots = [];
				for( i=0; i < dots.length; i++) {
					if (dots[i].count > 0) {
						noZeroDots.push(dots[i]);
					}
				}
				return noZeroDots;
			}
		</script>

	</body>

</html>
